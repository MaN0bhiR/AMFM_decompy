=====
pyQHM
=====

The algorithms here implemented were the QHM (Quasi-Harmonic Model), and its upgrades, aQHM (adaptive Quasi-Harmonic Model) and eaQHM (extended adaptive Quasi-Harmonic Model). Their formulation can be found at references [1-3].

These algorithms perform the so-called AM-FM decomposition. This designation is used due the fact that, in this method, the signal is modeled as a sum of amplitude- and frequency-modulated components. The goal is to overcome the drawbacks from Fourier-alike techniques, e.g. SFFT, wavelets, etc, which are limited in the time-frequency analysis by the so-called Heisenberg-Gabor inequality.

-----------
Quick start
-----------

The pyQHM module provides a function for each of the QHM family algorithms:

USAGE:

.. py:function:: qhm(signal, pitch, window[, samp_jump=None, N_iter=1, phase_tech='phase'])
                 aqhm(signal, previous_HM, pitch, window[, samp_jump=None, N_iter=1, N_runs=float('Inf'), phase_tech='phase'])
                 eaqhm(signal, previous_HM, pitch, window[, samp_jump=None, N_iter=1, N_runs=float('Inf'), phase_tech='phase'])
    :module: amfm_decompy.pyQHM

    :param signal: contains the signal data and its parameters.
    :param pitch: contains the pitch track and its parameters.
    :param window: contains the sample window and some reference arrays.
    :param samp_jump: distance in seconds between the center of a extracting frame and the center of its adjacent neighbours (default: sample by sample).
    :param N_iter: number of iterations for each frame (default: 1).
    :param N_runs: after (default: keeps restarting the algorithm until the output SRER stops growing).
    :param phase_tech: chooses the post-processing technique posterior The objective is to provide smoother bases for further aQHM and eaQHM calculations. Normally the extracted phase (default) it's enough, since that when samp_jump is d. However, in a sample by sample analysis cummulative

    :type signal: signal object
    :type pitch: pitch object
    :type window: window object
    :type samp_jump: float
    :type N_iter: int
    :type N_runs: int
    :type phase_tech: str
    :rtype: modulated signal object

blabla
